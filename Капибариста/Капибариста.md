**Описание**

В уютной местной кофейне система распознаёт посетителей по лицу, и капиварка автоматически наливает им именно тот напиток, который они любят больше всего.
Но новый капибариста неправильно ввел пароль в панели управления, программа сбросилась и теперь по умолчанию готовит латте на соевом молоке.
Неведомым образом это отразилось на характере любителей кофе — они стали излишне ранимыми. Восстановите доступ капибариста к системе.
Панель управления: t-barista-jcs7gs28.spbctf.org/

**Решение**

На сайте нас встречает панель управления, к которой нам необходимо восстановить доступ:

![image](https://github.com/user-attachments/assets/278d35e5-58ba-4ea3-bec9-efbf5ec8a67c)

Посмотрим файлик "Политика в отношении обработки персональных данных", в конце файла видим ссылку на некий [ресурс](https://t-barista-adminfilestorage-1yjec62t.spbctf.org/?path=policy.pdf):

![image](https://github.com/user-attachments/assets/1e6a95f3-caf7-4682-935c-c2a160a53aaf)

Перейдя по ссылке, мы видим некую файловую систему, путь в которой изменяется параметром path:

![image](https://github.com/user-attachments/assets/1b41aa33-a529-4527-8bfc-9d2346cf083a)

Можем сразу попробовать проэксплуатировать уязвимость PathTraversal и выйти за доступный рамки файловой системы, используя относительный путь:

![image](https://github.com/user-attachments/assets/10ef4cc1-1dca-49d6-b58d-0f69470e73b4)

Видим, что сайт так или иначе, проверяет этот параметр и так уж нагло не дает выйти за рамки:

![image](https://github.com/user-attachments/assets/d5c9bd54-3893-4b47-b36f-efbccf1cc4f7)

Покопавшись в файлах, натыкаемся на исходники этого сайта:

![image](https://github.com/user-attachments/assets/e52237ce-0691-493d-a9e4-8c9bde9289f2)

```
import base64
import mimetypes

from flask import Flask, request, render_template, abort, send_file
import os
import time

app = Flask(__name__)

BASE_DIR = '/fileshare/'


@app.route("/", methods=["GET"])
def main():
    action = request.args.get('action', '')
    user_path = request.args.get('path', '').replace('\\', '/')
    dirs = list(filter(None, user_path.split('/')))
    current_level = 0
    for dir_ in dirs:
        if dir_ == '..':
            current_level -= 1
        else:
            current_level += 1
        if current_level < 0:
            abort(403, 'Попытка взлома')
    allow_up = current_level > 0

    path = f"{BASE_DIR}/{user_path}"
    if not os.path.exists(path):
        abort(404)
    if os.path.isdir(path):
        files_info = []
        dirs_info = []
        for root, dirs, files in os.walk(path):
            for file in files:
                file_path = os.path.join(root, file)
                file_data = {
                    'name': file,
                    'file_size': os.path.getsize(file_path),
                    'date_created': time.ctime(os.path.getctime(file_path)),
                    'date_modified': time.ctime(os.path.getmtime(file_path))
                }
                files_info.append(file_data)
            for dir in dirs:
                dir_path = os.path.join(root, dir)
                dir_data = {
                    'name': dir,
                    'date_created': time.ctime(os.path.getctime(dir_path)),
                    'date_modified': time.ctime(os.path.getmtime(dir_path))
                }
                dirs_info.append(dir_data)
            break
        return render_template("dir.html", path=user_path, dirs_info=dirs_info, files_info=files_info, allow_up=allow_up)
    elif os.path.isfile(path):
        if action == 'download':
            return send_file(path, as_attachment=False)
        mime = mimetypes.guess_type(path)
        file = open(path, 'rb')
        image = None
        data = None
        ext = path.rsplit('.')[-1]
        if (mime[0] and mime[0].startswith('image/')) or ext in ['jfif', 'webp']:
            image = base64.b64encode(file.read()).decode()
        else:
            data = file.read(3000).decode('utf-8', errors='backslashreplace')
        return render_template("file.html", path=user_path, image=image, data=data)
```
В коде можно заметить фрагмент, который как раз и выявляет Попытку взлома:

```
action = request.args.get('action', '')
    user_path = request.args.get('path', '').replace('\\', '/')
    dirs = list(filter(None, user_path.split('/')))
    current_level = 0
    for dir_ in dirs:
        if dir_ == '..':
            current_level -= 1
        else:
            current_level += 1
        if current_level < 0:
            abort(403, 'Попытка взлома')
    allow_up = current_level > 0
```

Он просто считает количество "." и "/" в параметре. Такую простую проверку можно обмануть немного изменив наш путь на "./.././", что мы и сделаем:

![image](https://github.com/user-attachments/assets/38875266-4ec5-48f4-b3d1-812db61e09de)

Таким образом мы получили полный доступ к системе. С этого можно начать восстановление пароля.

Использовав путь "/./.././/mnt/C/Users" мы находим пользователя capybarman, чей пароль от веб-платформы нам и надо восстановить.

![image](https://github.com/user-attachments/assets/ea2a4f9e-122c-493b-bf5a-04279e976d7e)

Начать стоит с получения пароля самого пользователя системы. 
